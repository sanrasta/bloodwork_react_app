# ğŸ§  Cursor Rules â€“ Feature-Based Architecture

We use zustand for complex state management, and react-query for async fetching of data from our backend.

This project uses a **feature-first folder structure**, where each feature owns its:

- âœ… UI components
- âœ… Business logic
- âœ… State management (via Zustand or context)
- âœ… API integration logic
- âœ… Validation schemas
- âœ… Types/interfaces

The goal is to **encapsulate all logic related to a specific feature** inside a dedicated folder. This enables high cohesion and makes features easier to reason about, scale, and reuse.

---

## ğŸ“ Folder Structure (Feature Example)

```
src/
â””â”€â”€ features/
    â””â”€â”€ bloodwork-results/
        â”œâ”€â”€ components/
        â”‚   â”œâ”€â”€ bloodwork-list.tsx
        â”‚   â”œâ”€â”€ bloodwork-list-item.tsx
        â”‚   â””â”€â”€ bloodwork-list-skeleton.tsx
        â”‚
        â”œâ”€â”€ hooks/
        â”‚   â”œâ”€â”€ use-bloodwork-queries.ts
        â”‚   â””â”€â”€ use-bloodwork-validation.ts
        â”‚
        â”œâ”€â”€ api/
        â”‚   â””â”€â”€ bloodwork-api.ts
        â”‚
        â”œâ”€â”€ store/
        â”‚   â””â”€â”€ use-bloodwork-store.ts
        â”‚
        â”œâ”€â”€ types/
        â”‚   â””â”€â”€ types.ts
        â”‚
        â””â”€â”€ schemas/
            â””â”€â”€ bloodwork-schema.ts
```

> Note: Not every feature will include all of these folders. Add only what's necessary. Some features may include extra folders such as `schemas`, `interfaces`, or `constants` when needed.

---

## ğŸ“¦ Folder Guidelines

### `components/`

Holds all UI pieces related to the feature. These components are **feature-scoped**, meaning they should not be reused outside unless they're explicitly made reusable.

### `hooks/`

Feature-specific custom hooks, often for syncing with form state, performing validation, triggering debounced logic, etc.

### `api/`

Functions that call our backend (REST) These wrap a custom `fetch()`.

### `store/`

Zustand or local state containers that persist state across multiple steps or screens within the feature.

### `types/`

TypeScript types/interfaces for the feature's forms, outputs, prompts, etc.

### `schemas/`

Zod schemas for validation and inference. May include multiple schemas for multi-step forms or complex input/output structures.

---

## âœ… Best Practices

- Keep validation scoped to each step using Zod.
- Store multi-step form state in Zustand for final submission.
- Avoid leaking feature logic into global app state.
- Use `api/submit-something.ts` as single-responsibility POST/GET handlers.

---

## ğŸ§  React Native State Management Rules

When your new state depends on the previous state we don't do:
```typescript
// âŒ Don't do this
setCourseGoals([...courseGoals, enteredGoalText]);
```

Instead we do:
```typescript
// âœ… Do this
setCourseGoals(currentCourseGoals => [...currentCourseGoals, enteredGoalText]);
```

---

## ğŸ§  Tagging Your AI Agent

When creating a new feature:

- Create a folder inside `src/features/[feature-name]`
- Add only the folders needed (`components`, `store`, etc)
- Structure business logic and UI locally inside that feature folder
- Refer to this file for how to name and organize folders/files

---

## ğŸ“Œ Example: Bloodwork Results Flow

- List View: `bloodwork-list.tsx` (uses `use-bloodwork-queries.ts`)
- Detail View: `bloodwork-detail.tsx` (uses `use-bloodwork-queries.ts`)
- Form submission pulls data from `use-bloodwork-store.ts` and uses `bloodwork-api.ts`

This ensures clean separation of concerns, scoped validation, and easily testable logic.

---

## ğŸ’» UI Component Structure for Data Fetching

When a UI component needs to fetch data using a React Query hook (`useQuery`), it should consistently handle the different states of the data fetching lifecycle: Loading, Error, and Success. This ensures a robust and predictable user experience.

**Standard Pattern:**

1.  **Fetch Data:** Call the relevant `useQuery` hook (e.g., `useGetBloodworkResults()`) at the top of the component. Destructure the necessary state variables: `data`, `isLoading`, `isError`, and optionally `error`.

2.  **Handle Loading State:** Check the `isLoading` boolean. If `true`, return a loading indicator. Prefer using **skeleton loaders** that mimic the layout of the final UI to reduce layout shifts and perceived loading time.

3.  **Handle Error State:** Check the `isError` boolean. If `true`, return an appropriate error component or message. You can optionally use the `error` object returned by the hook for more specific error handling or logging.

4.  **Render Success State:** If neither `isLoading` nor `isError` is `true`, it's safe to assume the data fetching was successful and the `data` is available (though you might add an extra check for `data` existence if the API could potentially return successfully with no data). Render the main UI of the component, passing the fetched `data` to the necessary child components.

**Example (`bloodwork-list.tsx`):**

```typescript
export default function BloodworkList({ onSelectResult }: BloodworkListProps) {
  const filters = useBloodworkStore((state) => state.filters);
  
  // 1. Fetch Data
  const { data: results, isLoading, isError, error } = useGetBloodworkResults(filters);

  // 2. Handle Loading State
  if (isLoading) {
    return <BloodworkListSkeleton />;
  }

  // 3. Handle Error State
  if (isError || !results) {
    if (error) {
      console.error('Error fetching bloodwork results:', error);
    }
    return <ErrorComponent message={error?.message} />;
  }

  // 4. Render Success State
  return (
    <FlatList
      data={results}
      renderItem={({ item }) => (
        <BloodworkListItem result={item} onPress={() => onSelectResult?.(item)} />
      )}
    />
  );
}
```

This pattern provides a clear and repeatable structure for handling asynchronous data within UI components.

---

## ğŸ“ Current Project Structure

```
bloodwork_app/
â”œâ”€â”€ app/                          # Expo Router pages
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ features/                 # Feature-based modules
â”‚   â”‚   â”œâ”€â”€ bloodwork-results/    # Example feature
â”‚   â”‚   â””â”€â”€ user-profile/         # Example feature
â”‚   â”œâ”€â”€ shared/                   # Shared/reusable code
â”‚   â”‚   â”œâ”€â”€ components/           # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ hooks/               # Shared custom hooks
â”‚   â”‚   â”œâ”€â”€ api/                 # Base API client
â”‚   â”‚   â”œâ”€â”€ types/               # Global types
â”‚   â”‚   â””â”€â”€ utils/               # Utility functions
â”‚   â””â”€â”€ lib/                     # Third-party configurations
â”œâ”€â”€ assets/                      # Static assets
â””â”€â”€ components/                  # Legacy components (move to src/shared)
```

---
