# 🧠 Cursor Rules – Feature-Based Architecture

We use zustand for complex state management, and react-query for async fetching of data from our backend.

This project uses a **feature-first folder structure**, where each feature owns its:

- ✅ UI components
- ✅ Business logic
- ✅ State management (via Zustand or context)
- ✅ API integration logic
- ✅ Validation schemas
- ✅ Types/interfaces

The goal is to **encapsulate all logic related to a specific feature** inside a dedicated folder. This enables high cohesion and makes features easier to reason about, scale, and reuse.

---

## 📁 Folder Structure (Feature Example)

```
src/
└── features/
    └── bloodwork-results/
        ├── components/
        │   ├── bloodwork-list.tsx
        │   ├── bloodwork-list-item.tsx
        │   └── bloodwork-list-skeleton.tsx
        │
        ├── hooks/
        │   ├── use-bloodwork-queries.ts
        │   └── use-bloodwork-validation.ts
        │
        ├── api/
        │   └── bloodwork-api.ts
        │
        ├── store/
        │   └── use-bloodwork-store.ts
        │
        ├── types/
        │   └── types.ts
        │
        └── schemas/
            └── bloodwork-schema.ts
```

> Note: Not every feature will include all of these folders. Add only what's necessary. Some features may include extra folders such as `schemas`, `interfaces`, or `constants` when needed.

---

## 📦 Folder Guidelines

### `components/`

Holds all UI pieces related to the feature. These components are **feature-scoped**, meaning they should not be reused outside unless they're explicitly made reusable.

### `hooks/`

Feature-specific custom hooks, often for syncing with form state, performing validation, triggering debounced logic, etc.

### `api/`

Functions that call our backend (REST) These wrap a custom `fetch()`.

### `store/`

Zustand or local state containers that persist state across multiple steps or screens within the feature.

### `types/`

TypeScript types/interfaces for the feature's forms, outputs, prompts, etc.

### `schemas/`

Zod schemas for validation and inference. May include multiple schemas for multi-step forms or complex input/output structures.

---

## ✅ Best Practices

- Keep validation scoped to each step using Zod.
- Store multi-step form state in Zustand for final submission.
- Avoid leaking feature logic into global app state.
- Use `api/submit-something.ts` as single-responsibility POST/GET handlers.

---

## 🧠 React Native State Management Rules

When your new state depends on the previous state we don't do:
```typescript
// ❌ Don't do this
setCourseGoals([...courseGoals, enteredGoalText]);
```

Instead we do:
```typescript
// ✅ Do this
setCourseGoals(currentCourseGoals => [...currentCourseGoals, enteredGoalText]);
```

---

## 🧠 Tagging Your AI Agent

When creating a new feature:

- Create a folder inside `src/features/[feature-name]`
- Add only the folders needed (`components`, `store`, etc)
- Structure business logic and UI locally inside that feature folder
- Refer to this file for how to name and organize folders/files

---

## 📌 Example: Bloodwork Results Flow

- List View: `bloodwork-list.tsx` (uses `use-bloodwork-queries.ts`)
- Detail View: `bloodwork-detail.tsx` (uses `use-bloodwork-queries.ts`)
- Form submission pulls data from `use-bloodwork-store.ts` and uses `bloodwork-api.ts`

This ensures clean separation of concerns, scoped validation, and easily testable logic.

---

## 💻 UI Component Structure for Data Fetching

When a UI component needs to fetch data using a React Query hook (`useQuery`), it should consistently handle the different states of the data fetching lifecycle: Loading, Error, and Success. This ensures a robust and predictable user experience.

**Standard Pattern:**

1.  **Fetch Data:** Call the relevant `useQuery` hook (e.g., `useGetBloodworkResults()`) at the top of the component. Destructure the necessary state variables: `data`, `isLoading`, `isError`, and optionally `error`.

2.  **Handle Loading State:** Check the `isLoading` boolean. If `true`, return a loading indicator. Prefer using **skeleton loaders** that mimic the layout of the final UI to reduce layout shifts and perceived loading time.

3.  **Handle Error State:** Check the `isError` boolean. If `true`, return an appropriate error component or message. You can optionally use the `error` object returned by the hook for more specific error handling or logging.

4.  **Render Success State:** If neither `isLoading` nor `isError` is `true`, it's safe to assume the data fetching was successful and the `data` is available (though you might add an extra check for `data` existence if the API could potentially return successfully with no data). Render the main UI of the component, passing the fetched `data` to the necessary child components.

**Example (`bloodwork-list.tsx`):**

```typescript
export default function BloodworkList({ onSelectResult }: BloodworkListProps) {
  const filters = useBloodworkStore((state) => state.filters);
  
  // 1. Fetch Data
  const { data: results, isLoading, isError, error } = useGetBloodworkResults(filters);

  // 2. Handle Loading State
  if (isLoading) {
    return <BloodworkListSkeleton />;
  }

  // 3. Handle Error State
  if (isError || !results) {
    if (error) {
      console.error('Error fetching bloodwork results:', error);
    }
    return <ErrorComponent message={error?.message} />;
  }

  // 4. Render Success State
  return (
    <FlatList
      data={results}
      renderItem={({ item }) => (
        <BloodworkListItem result={item} onPress={() => onSelectResult?.(item)} />
      )}
    />
  );
}
```

This pattern provides a clear and repeatable structure for handling asynchronous data within UI components.

---

## 📁 Current Project Structure

```
bloodwork_app/
├── app/                          # Expo Router pages
├── src/
│   ├── features/                 # Feature-based modules
│   │   ├── bloodwork-results/    # Example feature
│   │   └── user-profile/         # Example feature
│   ├── shared/                   # Shared/reusable code
│   │   ├── components/           # Reusable UI components
│   │   ├── hooks/               # Shared custom hooks
│   │   ├── api/                 # Base API client
│   │   ├── types/               # Global types
│   │   └── utils/               # Utility functions
│   └── lib/                     # Third-party configurations
├── assets/                      # Static assets
└── components/                  # Legacy components (move to src/shared)
```

---
